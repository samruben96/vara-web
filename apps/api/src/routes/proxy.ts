/**
 * Image Proxy Routes
 *
 * Provides a public endpoint for serving protected images via short-lived tokens.
 * This endpoint is PUBLIC (no authentication required) to allow external services
 * like SerpAPI to fetch images.
 *
 * Security:
 * - Tokens are cryptographically secure random values
 * - Tokens have a short TTL (2-5 minutes)
 * - Tokens are single-use friendly (can be invalidated after use)
 * - No direct access to storage paths is exposed
 *
 * @example
 * GET /api/v1/proxy/images/:token
 * - Returns the image binary if token is valid
 * - Returns 404 if token is invalid or expired
 */

import type { FastifyInstance } from 'fastify';
import { z } from 'zod';
import { imageProxyService } from '../services/proxy';
import { supabaseAdmin } from '../config/supabase';
import { prisma } from '../config/prisma';

/** Supabase Storage bucket name for protected images */
const STORAGE_BUCKET = 'protected-images';

/**
 * Schema for validating route parameters
 */
const proxyParamsSchema = z.object({
  token: z.string().min(1),
});

/**
 * MIME types for image responses
 */
const MIME_TYPES: Record<string, string> = {
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.png': 'image/png',
  '.webp': 'image/webp',
  '.gif': 'image/gif',
};

/**
 * Gets the MIME type from a file path based on extension
 */
function getMimeType(path: string): string {
  const ext = path.toLowerCase().match(/\.[^.]+$/)?.[0] || '';
  return MIME_TYPES[ext] || 'application/octet-stream';
}

/**
 * Extracts the storage path from a full storage URL
 * URL format: supabase_url/storage/v1/object/bucket/path
 */
function extractStoragePath(storageUrl: string): string | null {
  const prefix = `/storage/v1/object/${STORAGE_BUCKET}/`;
  const index = storageUrl.indexOf(prefix);
  if (index === -1) return null;
  return storageUrl.substring(index + prefix.length);
}

/**
 * Proxy routes for serving protected images via short-lived tokens.
 *
 * IMPORTANT: These routes are PUBLIC (no authentication) to allow
 * external services like SerpAPI to fetch images.
 */
export async function proxyRoutes(app: FastifyInstance) {
  /**
   * GET /images/:token
   *
   * Serves a protected image via its proxy token.
   * This endpoint is PUBLIC to allow external services to fetch images.
   *
   * @param token - The proxy token generated by ImageProxyService
   * @returns The image binary with appropriate Content-Type
   */
  app.get('/images/:token', async (request, reply) => {
    const parseResult = proxyParamsSchema.safeParse(request.params);

    if (!parseResult.success) {
      request.log.debug({ params: request.params }, 'Invalid proxy token format');
      return reply.code(404).send({ error: 'Not found' });
    }

    const { token } = parseResult.data;

    // Validate the token
    const validation = imageProxyService.validateToken(token);

    if (!validation.valid) {
      request.log.debug(
        { token: token.substring(0, 8) + '...', error: validation.error },
        'Invalid or expired proxy token'
      );
      return reply.code(404).send({ error: 'Not found or expired' });
    }

    const { imageId, storagePath: cachedStoragePath } = validation;

    try {
      // Get storage path - either from cache or by looking up the image
      let storagePath = cachedStoragePath;

      if (!storagePath) {
        // Look up the image in the database to get storage URL
        const image = await prisma.protectedImage.findUnique({
          where: { id: imageId },
          select: { storageUrl: true, status: true },
        });

        if (!image || image.status === 'ARCHIVED') {
          request.log.warn({ imageId }, 'Image not found or archived');
          return reply.code(404).send({ error: 'Not found' });
        }

        const extractedPath = extractStoragePath(image.storageUrl);

        if (!extractedPath) {
          request.log.error({ imageId, storageUrl: image.storageUrl }, 'Invalid storage URL format');
          return reply.code(500).send({ error: 'Internal error' });
        }

        storagePath = extractedPath;
      }

      // Download the image from Supabase Storage
      const { data: blob, error: downloadError } = await supabaseAdmin.storage
        .from(STORAGE_BUCKET)
        .download(storagePath);

      if (downloadError || !blob) {
        request.log.error(
          { imageId, storagePath, error: downloadError?.message },
          'Failed to download image from storage'
        );
        return reply.code(404).send({ error: 'Not found' });
      }

      // Convert Blob to Buffer
      const arrayBuffer = await blob.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);

      // Determine Content-Type from storage path
      const contentType = getMimeType(storagePath);

      request.log.debug(
        { imageId, contentType, size: buffer.length },
        'Serving image via proxy'
      );

      // Send the image with appropriate headers
      return reply
        .header('Content-Type', contentType)
        .header('Content-Length', buffer.length)
        .header('Cache-Control', 'no-store, no-cache, must-revalidate')
        .header('Pragma', 'no-cache')
        .header('Expires', '0')
        .send(buffer);
    } catch (error) {
      request.log.error(
        { imageId, error: error instanceof Error ? error.message : 'Unknown error' },
        'Error serving proxied image'
      );
      return reply.code(500).send({ error: 'Internal error' });
    }
  });

  /**
   * Health check for proxy service
   * GET /health
   *
   * Returns basic stats about the proxy service.
   */
  app.get('/health', async (_request, reply) => {
    return reply.send({
      status: 'ok',
      activeTokens: imageProxyService.getActiveTokenCount(),
      timestamp: new Date().toISOString(),
    });
  });
}
